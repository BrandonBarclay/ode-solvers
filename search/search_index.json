{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"img.latex-inline { vertical-align: middle; } ODEs Solving in Rust Ode-solvers is a toolbox offering several methods to solve ordinary differential equations (ODEs) in Rust. The following instructions should get you up and running in no time. Importing the crate To start using the crate in your project, add the following dependency in your project's Cargo.toml file: [dependencies] ode-solvers = 0.1.0 Then, in your main file, add extern crate ode-solvers; use ode-solvers::*; Type alias definition The numerical integration methods implemented in the crate support multi-dimensional systems. In order to define the dimension of the system, declare a type alias for the state vector. For instance type State = Vector3 f64 ; The state representation of the system is based on the VectorN T,D structure defined in the nalgebra crate. For convenience, ode-solvers re-exports six types to work with systems of dimension 1 to 6: Vector1 T ,..., Vector6 T . For higher dimensions, the user should import the nalgebra crate and define a VectorN T,D where the second type parameter of VectorN is a dimension name defined in nalgebra. Note that the type T must be f64. For instance, for a 9-dimensional system, one would have: extern crate nalgebra as na; type State = VectorN f64, na::U9 ; System definition The first order ODE(s) must be defined in a function with the following signature fn system(x: f64, y: State) - State where the first argument is the independent variable (usually time) and the second one is a vector containing the dependent variable(s). Method selection The following explicit Runge-Kutta methods are implemented in the current version (0.1.0) of the crate: Method Name Order Error estimate order Dense output order Dormand-Prince Dopri5 5 4 4 Dormand-Prince Dop853 8 (5,3) 7 These methods are defined in the modules dopri5 and dop853 and feature: Adaptive step size control Automatic initial step size selection Sparse or dense output The first step is to bring the desired module into scope: use ode_solvers::dopri5::*; Then, a structure is created using the new or the from_param method of the corresponding struct. Refer to the API documentation for a description of the input arguments. let mut stepper = Dopri5::new(system, x0, x_end, dx, y0, rtol, atol); The system is integrated using let res = stepper.integrate(); which returns Result Stats, IntegrationError . Upon successful completion, res = Ok(Stats) where Stats is a structure containing some information on the integration process. If an error occurs, res = Err(IntegrationError). Finally, the results can be retrieved with let x_out = stepper.x_out(); let y_out = stepper.y_out(); Adaptive Step Size The adaptive step size is computed using a PI controller where is a safety factor (usually 0.9), is the current error , and is the previous error. The coefficients and determine the behavior of the controller. In order to make sure that doesn't change too abruptly, bounds on the factor of are enforced: If , then and if , . The default values of these parameters are listed in the table below. Dopri5 Dopri853 0.17 1/8 0.04 0 0.2 0.333 10.0 6.0 0.9 0.9 These default values can be overridden by using the method from_param . For Dopri5, a 5th order approximation and a 4th order approximation are constructed using the coefficients of the method. The error estimator is then where is the dimension of the system and is a scale factor given by For Dop853, an 8th order approximation , a 5th order approximation , and a 3rd order approximation are constructed using the coefficients of the method. Two error estimators are computed: and which are combined into a single error estimator For a thorough discussion, see Hairer et al. [1]. References and Acknowledgments The algorithms implemented in this crate are described in references [1] and [2]. They were originally implemented in FORTRAN by E. Hairer and G. Wanner, Universit\u00e9 de Gen\u00e8ve, Switzerland. This Rust implementation has been adapted from the C version written by J. Colinge, Universit\u00e9 de Gen\u00e8ve, Switzerland and the C++ version written by Blake Ashby, Stanford University, USA. [1] Hairer, E., N\u00f8rsett, S.P., Wanner, G., Solving Ordinary Differential Equations I, Nonstiff Problems , Second Revised Edition, Springer, 2008 [2] Hairer, E., Wanner, G., Solving Ordinary Differential Equations II, Stiff and Differential-Algebraic Problems , Second Revised Edition, Springer, 2002 [3] Butcher, J.C., Numerical Methods for Ordinary Differential Equations , Third Edition, John Wiley and Sons, 2016 [4] Gustafsson, K., Control-Theoretic Techniques for Stepsize Selection in Explicit Runge-Kutta Methods. ACM Transactions on Mathematical Software , 17, 4 (December 1991), 533-554. [5] Gustafsson, K., Control-Theoretic Techniques for Stepsize Selection in Implicit Runge-Kutta Methods. ACM Transactions on Mathematical Software , 20, 4 (December 1994), 496-517. [6] S\u00f6derlind, G., Automatic Control and Adaptive Time-Stepping, Numerical Algorithms (2002) 31: 281-310.","title":"Quick reference"},{"location":"index.html#odes-solving-in-rust","text":"Ode-solvers is a toolbox offering several methods to solve ordinary differential equations (ODEs) in Rust. The following instructions should get you up and running in no time.","title":"ODEs Solving in Rust"},{"location":"index.html#importing-the-crate","text":"To start using the crate in your project, add the following dependency in your project's Cargo.toml file: [dependencies] ode-solvers = 0.1.0 Then, in your main file, add extern crate ode-solvers; use ode-solvers::*;","title":"Importing the crate"},{"location":"index.html#type-alias-definition","text":"The numerical integration methods implemented in the crate support multi-dimensional systems. In order to define the dimension of the system, declare a type alias for the state vector. For instance type State = Vector3 f64 ; The state representation of the system is based on the VectorN T,D structure defined in the nalgebra crate. For convenience, ode-solvers re-exports six types to work with systems of dimension 1 to 6: Vector1 T ,..., Vector6 T . For higher dimensions, the user should import the nalgebra crate and define a VectorN T,D where the second type parameter of VectorN is a dimension name defined in nalgebra. Note that the type T must be f64. For instance, for a 9-dimensional system, one would have: extern crate nalgebra as na; type State = VectorN f64, na::U9 ;","title":"Type alias definition"},{"location":"index.html#system-definition","text":"The first order ODE(s) must be defined in a function with the following signature fn system(x: f64, y: State) - State where the first argument is the independent variable (usually time) and the second one is a vector containing the dependent variable(s).","title":"System definition"},{"location":"index.html#method-selection","text":"The following explicit Runge-Kutta methods are implemented in the current version (0.1.0) of the crate: Method Name Order Error estimate order Dense output order Dormand-Prince Dopri5 5 4 4 Dormand-Prince Dop853 8 (5,3) 7 These methods are defined in the modules dopri5 and dop853 and feature: Adaptive step size control Automatic initial step size selection Sparse or dense output The first step is to bring the desired module into scope: use ode_solvers::dopri5::*; Then, a structure is created using the new or the from_param method of the corresponding struct. Refer to the API documentation for a description of the input arguments. let mut stepper = Dopri5::new(system, x0, x_end, dx, y0, rtol, atol); The system is integrated using let res = stepper.integrate(); which returns Result Stats, IntegrationError . Upon successful completion, res = Ok(Stats) where Stats is a structure containing some information on the integration process. If an error occurs, res = Err(IntegrationError). Finally, the results can be retrieved with let x_out = stepper.x_out(); let y_out = stepper.y_out();","title":"Method selection"},{"location":"index.html#adaptive-step-size","text":"The adaptive step size is computed using a PI controller where is a safety factor (usually 0.9), is the current error , and is the previous error. The coefficients and determine the behavior of the controller. In order to make sure that doesn't change too abruptly, bounds on the factor of are enforced: If , then and if , . The default values of these parameters are listed in the table below. Dopri5 Dopri853 0.17 1/8 0.04 0 0.2 0.333 10.0 6.0 0.9 0.9 These default values can be overridden by using the method from_param . For Dopri5, a 5th order approximation and a 4th order approximation are constructed using the coefficients of the method. The error estimator is then where is the dimension of the system and is a scale factor given by For Dop853, an 8th order approximation , a 5th order approximation , and a 3rd order approximation are constructed using the coefficients of the method. Two error estimators are computed: and which are combined into a single error estimator For a thorough discussion, see Hairer et al. [1].","title":"Adaptive Step Size"},{"location":"index.html#references-and-acknowledgments","text":"The algorithms implemented in this crate are described in references [1] and [2]. They were originally implemented in FORTRAN by E. Hairer and G. Wanner, Universit\u00e9 de Gen\u00e8ve, Switzerland. This Rust implementation has been adapted from the C version written by J. Colinge, Universit\u00e9 de Gen\u00e8ve, Switzerland and the C++ version written by Blake Ashby, Stanford University, USA. [1] Hairer, E., N\u00f8rsett, S.P., Wanner, G., Solving Ordinary Differential Equations I, Nonstiff Problems , Second Revised Edition, Springer, 2008 [2] Hairer, E., Wanner, G., Solving Ordinary Differential Equations II, Stiff and Differential-Algebraic Problems , Second Revised Edition, Springer, 2002 [3] Butcher, J.C., Numerical Methods for Ordinary Differential Equations , Third Edition, John Wiley and Sons, 2016 [4] Gustafsson, K., Control-Theoretic Techniques for Stepsize Selection in Explicit Runge-Kutta Methods. ACM Transactions on Mathematical Software , 17, 4 (December 1991), 533-554. [5] Gustafsson, K., Control-Theoretic Techniques for Stepsize Selection in Implicit Runge-Kutta Methods. ACM Transactions on Mathematical Software , 20, 4 (December 1994), 496-517. [6] S\u00f6derlind, G., Automatic Control and Adaptive Time-Stepping, Numerical Algorithms (2002) 31: 281-310.","title":"References and Acknowledgments"},{"location":"examples/kepler_orbit.html","text":"img.latex-inline { vertical-align: middle; } Kepler Orbit Problem Definition For this example, we consider a spacecraft on a Kepler orbit about the Earth and we want to predict its future trajectory. We assume that the elliptical orbit is described by the following classical orbital elements: Semi-major axis: a = 20,000 km Eccentricity: e = 0.7 Inclination: i = 35\u00b0 Right ascension of the ascending node: = 100\u00b0 Argument of perigee: = 65\u00b0 True anomaly: = 30\u00b0 The period of an orbit is given by where is the standard gravitational parameter. For the Earth, = 398600.4354 km 3 /s 2 and thus P = 2.8149 10 4 s = 7.82 hours. The initial position of the spacecraft expressed in Cartesian coordinates is and velocity such that the initial state vector is . The equations of motion describing the evolution of the system are where is the magnitude of . Since the crate handles first order ODEs, this system must be transformed into a state space form representation. An appropriate change of variables , , , , , yields which can be numerically integrated. Implementation The problem is solved using the Dopri5 method. We first import the crate and bring the required modules into scope: extern crate ode_solvers; use ode_solvers::*; use ode_solvers::dopri5::*; Next, two type aliases are defined: type State = Vector6 f64 ; type Time = f64; and the standard gravitational parameter is defined as a global constant: const MU: f64 = 398600.435436; The equations of motion are defined in the method system : fn system(_t: Time, y: State) - State { let r = (y[0]*y[0] + y[1]*y[1] + y[2]*y[2]).sqrt() ; let mut dy = State::zeros(); dy[0] = y[3]; dy[1] = y[4]; dy[2] = y[5]; dy[3] = -MU*y[0]/r.powi(3); dy[4] = -MU*y[1]/r.powi(3); dy[5] = -MU*y[2]/r.powi(3); dy } We now implement the main function. The orbital period is first calculated and the initial state is initialized. Then, a stepper is created using the Dopri5 structure. We pass in a handle to the function describing the system, the initial time, the final time, the time increment between two outputs, the initial state vector, the relative tolerance, and the absolute tolerance. The integration is launched by calling the method integrate() and the result is stored in res . Finally, a check on the outcome of the integration is performed and the outputs can be extracted. fn main() { let a: f64 = 20000.0; let period = 2.0*PI*(a.powi(3)/MU).sqrt(); let y0 = State::new(-5007.248417988539, -1444.918140151374, 3628.534606178356, 0.717716656891, -10.224093784269, 0.748229399696); let mut stepper = Dopri5::new(system, 0.0, 5.0*period, 60.0, y0, 1.0e-10, 1.0e-10); let res = stepper.integrate(); // Handle result match res { Ok(stats) = { stats.print(); // Do something with the output... // let path = Path::new( ./outputs/kepler_orbit_dopri5.dat ); // save(stepper.x_out(), stepper.y_out(), path); // println!( Results saved in: {:?} , path); }, Err(_) = println!( An error occured. ), } } Results The following figure shows the trajectory resulting from the integration. As expected, the orbit is closed. Some information on the integration process is provided in the stats variable: Number of function evaluations: 62835 Number of accepted steps: 10467 Number of rejected steps: 5 In order to assess the accuracy of the integration, we look at the specific orbital energy which is a constant of the motion. This specific energy is given by where is the amplitude of the velocity and is the distance from the Earth's center to the spacecraft. In theory, this value is constant as long as no external force acts on the system (which is the case here). From the intial conditions, the specific energy of this orbit is By computing for each time step and plotting the difference , we obtain the following time evolution of the error: As can be seen on this figure, the specific energy is constant up to the 9th digit after the decimal point which shows that the accuracy of the integration is quite good. A higher accuracy can be achieved by selecting smaller values for rtol and atol .","title":"Kepler Orbit"},{"location":"examples/kepler_orbit.html#kepler-orbit","text":"","title":"Kepler Orbit"},{"location":"examples/kepler_orbit.html#problem-definition","text":"For this example, we consider a spacecraft on a Kepler orbit about the Earth and we want to predict its future trajectory. We assume that the elliptical orbit is described by the following classical orbital elements: Semi-major axis: a = 20,000 km Eccentricity: e = 0.7 Inclination: i = 35\u00b0 Right ascension of the ascending node: = 100\u00b0 Argument of perigee: = 65\u00b0 True anomaly: = 30\u00b0 The period of an orbit is given by where is the standard gravitational parameter. For the Earth, = 398600.4354 km 3 /s 2 and thus P = 2.8149 10 4 s = 7.82 hours. The initial position of the spacecraft expressed in Cartesian coordinates is and velocity such that the initial state vector is . The equations of motion describing the evolution of the system are where is the magnitude of . Since the crate handles first order ODEs, this system must be transformed into a state space form representation. An appropriate change of variables , , , , , yields which can be numerically integrated.","title":"Problem Definition"},{"location":"examples/kepler_orbit.html#implementation","text":"The problem is solved using the Dopri5 method. We first import the crate and bring the required modules into scope: extern crate ode_solvers; use ode_solvers::*; use ode_solvers::dopri5::*; Next, two type aliases are defined: type State = Vector6 f64 ; type Time = f64; and the standard gravitational parameter is defined as a global constant: const MU: f64 = 398600.435436; The equations of motion are defined in the method system : fn system(_t: Time, y: State) - State { let r = (y[0]*y[0] + y[1]*y[1] + y[2]*y[2]).sqrt() ; let mut dy = State::zeros(); dy[0] = y[3]; dy[1] = y[4]; dy[2] = y[5]; dy[3] = -MU*y[0]/r.powi(3); dy[4] = -MU*y[1]/r.powi(3); dy[5] = -MU*y[2]/r.powi(3); dy } We now implement the main function. The orbital period is first calculated and the initial state is initialized. Then, a stepper is created using the Dopri5 structure. We pass in a handle to the function describing the system, the initial time, the final time, the time increment between two outputs, the initial state vector, the relative tolerance, and the absolute tolerance. The integration is launched by calling the method integrate() and the result is stored in res . Finally, a check on the outcome of the integration is performed and the outputs can be extracted. fn main() { let a: f64 = 20000.0; let period = 2.0*PI*(a.powi(3)/MU).sqrt(); let y0 = State::new(-5007.248417988539, -1444.918140151374, 3628.534606178356, 0.717716656891, -10.224093784269, 0.748229399696); let mut stepper = Dopri5::new(system, 0.0, 5.0*period, 60.0, y0, 1.0e-10, 1.0e-10); let res = stepper.integrate(); // Handle result match res { Ok(stats) = { stats.print(); // Do something with the output... // let path = Path::new( ./outputs/kepler_orbit_dopri5.dat ); // save(stepper.x_out(), stepper.y_out(), path); // println!( Results saved in: {:?} , path); }, Err(_) = println!( An error occured. ), } }","title":"Implementation"},{"location":"examples/kepler_orbit.html#results","text":"The following figure shows the trajectory resulting from the integration. As expected, the orbit is closed. Some information on the integration process is provided in the stats variable: Number of function evaluations: 62835 Number of accepted steps: 10467 Number of rejected steps: 5 In order to assess the accuracy of the integration, we look at the specific orbital energy which is a constant of the motion. This specific energy is given by where is the amplitude of the velocity and is the distance from the Earth's center to the spacecraft. In theory, this value is constant as long as no external force acts on the system (which is the case here). From the intial conditions, the specific energy of this orbit is By computing for each time step and plotting the difference , we obtain the following time evolution of the error: As can be seen on this figure, the specific energy is constant up to the 9th digit after the decimal point which shows that the accuracy of the integration is quite good. A higher accuracy can be achieved by selecting smaller values for rtol and atol .","title":"Results"},{"location":"examples/three_body_problem.html","text":"img.latex-inline { vertical-align: middle; } Three-Body Problem Problem Definition In this problem, we consider the circular restricted three body problem in which a spacecraft evolves under the influence of the Earth and the Moon. The second order nondimensional equations of motion of this problem are where is a parameter of the system. For the Earth-Moon system, . Rewriting this system in state space form yields Implementation The problem is solved using Dop853. The crate is first imported and the modules are brought into scope: extern crate ode_solvers; use ode_solvers::*; use ode_solvers::dop853::*; Type aliases are then defined for the state vector and the time: type State = Vector6 f64 ; type Time = f64; Next, we define the problem specific constant const MU: f64 = 0.012300118882173; and finally the ODEs to be solved: fn system(_t: Time, y: State) - State { let d = ((y[0]+MU).powi(2) + y[1].powi(2) + y[2].powi(2)).sqrt(); let r = ((y[0]-1.0+MU).powi(2) + y[1].powi(2) + y[2].powi(2)).sqrt(); let mut dy = State::zeros(); dy[0] = y[3]; dy[1] = y[4]; dy[2] = y[5]; dy[3] = y[0] + 2.0*y[4] - (1.0-MU)*(y[0]+MU)/d.powi(3) - MU*(y[0]-1.0+MU)/r.powi(3); dy[4] = -2.0*y[3] + y[1] - (1.0-MU)*y[1]/d.powi(3) - MU*y[1]/r.powi(3); dy[5] = -(1.0-MU)*y[2]/d.powi(3) - MU*y[2]/r.powi(3); dy } The intial state vector of the spacecraft is defined in the main function. A Dop853 structure is created and the integrate() function is called. The result is handled with a match statement. fn main() { let y0 = State::new(-0.271, -0.42, 0.0, 0.3, -1.0, 0.0); let mut stepper = Dop853::new(system, 0.0, 150.0, 0.001, y0, 1.0e-14, 1.0e-14); let res = stepper.integrate(); // Handle result match res { Ok(stats) = { stats.print(); // Do something with the results... // let path = Path::new( ./outputs/three_body_dop853.dat ); // save(stepper.x_out(), stepper.y_out(), path); // println!( Results saved in: {:?} , path); }, Err(_) = println!( An error occured. ), } } Results The trajectory of the spacecraft for a duration of 150 (dimensionless time) is shown on the following figure: On that figure, the Earth is located at (0, 0) and the Moon is at (0.9877, 0). We see that the spacecraft is first on an orbit about the Earth before moving to the vicinity of the Moon. The accuracy of the integration can be assessed by looking at the Jacobi constant. The Jacobi constant is given by and is an integral of the motion (i.e. is constant as long as no external force is applied). Based on the initial conditions, the Jacobi constant yields By computing the Jacobi constant at each time step and plotting the difference , we get the figure below: As can be seen on that figure, the Jacobi constant is constant up to the 11th digit after the decimal point. This accuracy is quite reasonable for that kind of problem but if a higher accuracy is required, the relative tolerance and/or the absolute tolerance could be reduced.","title":"Three-body Problem"},{"location":"examples/three_body_problem.html#three-body-problem","text":"","title":"Three-Body Problem"},{"location":"examples/three_body_problem.html#problem-definition","text":"In this problem, we consider the circular restricted three body problem in which a spacecraft evolves under the influence of the Earth and the Moon. The second order nondimensional equations of motion of this problem are where is a parameter of the system. For the Earth-Moon system, . Rewriting this system in state space form yields","title":"Problem Definition"},{"location":"examples/three_body_problem.html#implementation","text":"The problem is solved using Dop853. The crate is first imported and the modules are brought into scope: extern crate ode_solvers; use ode_solvers::*; use ode_solvers::dop853::*; Type aliases are then defined for the state vector and the time: type State = Vector6 f64 ; type Time = f64; Next, we define the problem specific constant const MU: f64 = 0.012300118882173; and finally the ODEs to be solved: fn system(_t: Time, y: State) - State { let d = ((y[0]+MU).powi(2) + y[1].powi(2) + y[2].powi(2)).sqrt(); let r = ((y[0]-1.0+MU).powi(2) + y[1].powi(2) + y[2].powi(2)).sqrt(); let mut dy = State::zeros(); dy[0] = y[3]; dy[1] = y[4]; dy[2] = y[5]; dy[3] = y[0] + 2.0*y[4] - (1.0-MU)*(y[0]+MU)/d.powi(3) - MU*(y[0]-1.0+MU)/r.powi(3); dy[4] = -2.0*y[3] + y[1] - (1.0-MU)*y[1]/d.powi(3) - MU*y[1]/r.powi(3); dy[5] = -(1.0-MU)*y[2]/d.powi(3) - MU*y[2]/r.powi(3); dy } The intial state vector of the spacecraft is defined in the main function. A Dop853 structure is created and the integrate() function is called. The result is handled with a match statement. fn main() { let y0 = State::new(-0.271, -0.42, 0.0, 0.3, -1.0, 0.0); let mut stepper = Dop853::new(system, 0.0, 150.0, 0.001, y0, 1.0e-14, 1.0e-14); let res = stepper.integrate(); // Handle result match res { Ok(stats) = { stats.print(); // Do something with the results... // let path = Path::new( ./outputs/three_body_dop853.dat ); // save(stepper.x_out(), stepper.y_out(), path); // println!( Results saved in: {:?} , path); }, Err(_) = println!( An error occured. ), } }","title":"Implementation"},{"location":"examples/three_body_problem.html#results","text":"The trajectory of the spacecraft for a duration of 150 (dimensionless time) is shown on the following figure: On that figure, the Earth is located at (0, 0) and the Moon is at (0.9877, 0). We see that the spacecraft is first on an orbit about the Earth before moving to the vicinity of the Moon. The accuracy of the integration can be assessed by looking at the Jacobi constant. The Jacobi constant is given by and is an integral of the motion (i.e. is constant as long as no external force is applied). Based on the initial conditions, the Jacobi constant yields By computing the Jacobi constant at each time step and plotting the difference , we get the figure below: As can be seen on that figure, the Jacobi constant is constant up to the 11th digit after the decimal point. This accuracy is quite reasonable for that kind of problem but if a higher accuracy is required, the relative tolerance and/or the absolute tolerance could be reduced.","title":"Results"}]}